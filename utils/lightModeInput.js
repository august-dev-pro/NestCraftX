/* const readline = require("readline-sync");
const { info, warning } = require("./colors");

async function getLightModeInputs(projectName, flags) {
  console.log(
    `\n${info("[MODE LIGHT]")} Configuration simplifiee pour ${projectName}\n`
  );

  const inputs = {
    projectName,
    mode: "light",
    useYarn: false,
    packageManager: "npm",
    entitiesData: {
      entities: [],
      relations: [],
    },
  };

  const orm = getOrmChoice(flags);
  const useAuth = getAuthChoice(flags);
  const useSwagger = getSwaggerChoice(flags);
  const useDocker = getDockerChoice(flags);

  inputs.selectedDB = orm === "mongoose" ? "mongodb" : "postgresql";

  if (orm === "mongoose") {
    inputs.dbConfig = {
      orm: "mongoose",
      MONGO_URI: readline.question(
        `URI MongoDB [mongodb://localhost:27017]: `,
        {
          defaultInput: "mongodb://localhost:27017",
        }
      ),
      MONGO_DB: readline.question(`Nom de la base [${projectName}]: `, {
        defaultInput: projectName,
      }),
    };
  } else {
    inputs.dbConfig = {
      orm,
      POSTGRES_USER: readline.question("Utilisateur PostgreSQL [postgres]: ", {
        defaultInput: "postgres",
      }),
      POSTGRES_PASSWORD: readline.question(
        "Mot de passe PostgreSQL [postgres]: ",
        {
          defaultInput: "postgres",
          hideEchoBack: false,
        }
      ),
      POSTGRES_DB: readline.question(`Nom de la base [${projectName}]: `, {
        defaultInput: projectName,
      }),
      POSTGRES_HOST: readline.question("Hote PostgreSQL [localhost]: ", {
        defaultInput: "localhost",
      }),
      POSTGRES_PORT: readline.question("Port PostgreSQL [5432]: ", {
        defaultInput: "5432",
      }),
    };
  }

  inputs.useAuth = useAuth;
  inputs.useSwagger = useSwagger;
  inputs.useDocker = useDocker;

  if (useSwagger) {
    inputs.swaggerInputs = {
      title: readline.question(`Titre API [${projectName} API]: `, {
        defaultInput: `${projectName} API`,
      }),
      description: readline.question(
        "Description [API generated by NestCraftX]: ",
        {
          defaultInput: "API generated by NestCraftX",
        }
      ),
      version: readline.question("Version [1.0.0]: ", {
        defaultInput: "1.0.0",
      }),
      endpoint: readline.question("Endpoint Swagger [api/docs]: ", {
        defaultInput: "api/docs",
      }),
    };
  }

  if (useAuth) {
    console.log(
      `${info("[INFO]")} Auth active : ajout automatique de l'entite User`
    );
    inputs.entitiesData.entities.push({
      name: "user",
      fields: [
        { name: "email", type: "string" },
        { name: "password", type: "string" },
        { name: "isActive", type: "boolean" },
      ],
    });
  }

  const addEntities = readline.keyInYNStrict(
    "Voulez-vous ajouter des entites supplementaires ?"
  );
  if (addEntities) {
    console.log(`\n${info("[INFO]")} Saisie des entites (mode simplifie)`);
    await addCustomEntities(inputs.entitiesData);
  }

  // Demander les relations entre entitÃ©s
  if (inputs.entitiesData.entities.length > 1) {
    const wantsRelation = readline.keyInYNStrict(
      "Voulez-vous ajouter des relations entre entites ?"
    );
    if (wantsRelation) {
      console.log(`\n${info("[INFO]")} Configuration des relations`);
      addRelations(inputs.entitiesData);
    }
  }

  return inputs;
}

function getOrmChoice(flags) {
  if (flags.orm) {
    const validOrms = ["prisma", "typeorm", "mongoose"];
    if (validOrms.includes(flags.orm)) {
      console.log(`${info("[INFO]")} ORM : ${flags.orm} (via flag)`);
      return flags.orm;
    }
  }

  let orm;
  while (true) {
    orm = readline.question(
      "Choisissez un ORM (prisma, typeorm, mongoose) [prisma]: ",
      {
        defaultInput: "prisma",
      }
    );
    if (["prisma", "typeorm", "mongoose"].includes(orm.toLowerCase())) {
      return orm.toLowerCase();
    }
    console.log(
      `${warning(
        "[WARNING]"
      )} ORM invalide. Choisissez : prisma, typeorm ou mongoose`
    );
  }
}

function getAuthChoice(flags) {
  if (flags.auth !== undefined) {
    console.log(
      `${info("[INFO]")} Auth : ${flags.auth ? "Oui" : "Non"} (via flag)`
    );
    return !!flags.auth;
  }
  return readline.keyInYNStrict("Activer l'authentification JWT ?");
}

function getSwaggerChoice(flags) {
  if (flags.swagger !== undefined) {
    console.log(
      `${info("[INFO]")} Swagger : ${flags.swagger ? "Oui" : "Non"} (via flag)`
    );
    return !!flags.swagger;
  }
  return readline.keyInYNStrict("Activer Swagger pour la documentation API ?");
}

function getDockerChoice(flags) {
  if (flags.docker !== undefined) {
    console.log(
      `${info("[INFO]")} Docker : ${flags.docker ? "Oui" : "Non"} (via flag)`
    );
    return flags.docker === true || flags.docker === "true";
  }
  return readline.keyInYNStrict("Generer les fichiers Docker ?");
}

async function addCustomEntities(entitiesData) {
  while (true) {
    let name;
    while (true) {
      name = readline.question("\nNom de l'entite (vide pour terminer) : ");
      if (!name) return;
      if (/^[A-Za-z][A-Za-z0-9_]*$/.test(name)) break;
      console.log(
        `${warning(
          "[WARNING]"
        )} Nom invalide. Utilisez lettres, chiffres et _ uniquement.`
      );
    }

    const fields = [];
    console.log(`Â  Champs pour l'entite "${name}" :`);

    while (true) {
      const fieldName = readline.question(
        "Â  Â  Nom du champ (vide pour terminer) : "
      );
      if (!fieldName) break;

      if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(fieldName)) {
        console.log(`${warning("[WARNING]")} Nom de champ invalide.`);
        continue;
      } // ðŸ›‘ LISTE COMPLÃˆTE DES TYPES (identique au Mode FULL)

      const baseTypeChoices = [
        "string",
        "text",
        "number",
        "decimal",
        "boolean",
        "Date",
        "uuid",
        "json",
        "enum",
        "array",
        "object",
      ];

      const typeQuestion = {
        type: "list",
        name: "ftype",
        message: `Type de "${fieldName}"`,
        default: "string",
        choices: baseTypeChoices,
      };

      const typeAnswer = await actualInquirer.prompt([typeQuestion]);
      let fieldType = typeAnswer.ftype; // --- LOGIQUE AVANCÃ‰E POUR ARRAY, ENUM, ET OBJECT ---

      if (fieldType === "array") {
        // Prompt spÃ©cifique pour le type interne du tableau
        const arrayInnerQuestion = {
          type: "list",
          name: "innerType",
          message: `Type des Ã©lÃ©ments de "${fieldName}[]"`,
          default: "string", // Exclure array et object du sous-type pour simplifier
          choices: baseTypeChoices.filter(
            (c) => c !== "array" && c !== "object"
          ),
        };

        const innerAnswer = await actualInquirer.prompt([arrayInnerQuestion]);
        fieldType = `${innerAnswer.innerType}[]`;
      } else if (fieldType === "enum") {
        const enumName = capitalize(fieldName) + "Enum";
        console.log(
          `Â  Â  ${info(
            "[INFO]"
          )} Type Enum sÃ©lectionnÃ©. Pensez Ã  dÃ©finir ${enumName} dans votre code.`
        );
        fieldType = enumName;
      } else if (fieldType === "object") {
        // Prompt pour nommer l'objet (ou 'json' par dÃ©faut)
        const objectNameQuestion = {
          type: "input",
          name: "objectName",
          message: `Nom du type complexe (DTO/Class ou laissez 'json') :`,
          default: "json",
        };

        const objectAnswer = await actualInquirer.prompt([objectNameQuestion]);
        fieldType = capitalize(objectAnswer.objectName.trim() || "json");
      } // ðŸŸ¢ AFFICHAGE PROPRE ET ALIGNÃ‰

      console.log(
        `Â  Â  Type du champ "${fieldName}" : ${fieldType} ${success("[âœ“]")}`
      );

      fields.push({ name: fieldName, type: fieldType });
    }

    if (fields.length > 0) {
      entitiesData.entities.push({ name, fields });
      console.log(
        `${info("[INFO]")} Entite "${name}" ajoutee avec ${
          fields.length
        } champ(s)`
      );
    }

    const addMore = readline.keyInYNStrict("Ajouter une autre entite ?");
    if (!addMore) break;
  }
}

function addRelations(entitiesData) {
  while (true) {
    console.log("\n  Entites disponibles :");
    entitiesData.entities.forEach((ent, index) =>
      console.log(`    [${index}] ${ent.name}`)
    );

    let fromIndex, toIndex;
    while (true) {
      fromIndex = parseInt(
        readline.question("  Depuis quelle entite ? (index) : "),
        10
      );
      if (!isNaN(fromIndex) && entitiesData.entities[fromIndex]) break;
      console.log(`${warning("[WARNING]")} Indice invalide.`);
    }
    while (true) {
      toIndex = parseInt(
        readline.question("  Vers quelle entite ? (index) : "),
        10
      );
      if (!isNaN(toIndex) && entitiesData.entities[toIndex]) break;
      console.log(`${warning("[WARNING]")} Indice invalide.`);
    }

    let relType;
    while (true) {
      relType = readline.question(
        "  Type de relation (1-1 / 1-n / n-1 / n-n) : "
      );
      if (["1-1", "1-n", "n-1", "n-n"].includes(relType)) break;
      console.log(
        `${warning("[WARNING]")} Type invalide. Choisissez : 1-1, 1-n, n-1, n-n`
      );
    }

    const from = entitiesData.entities[fromIndex];
    const to = entitiesData.entities[toIndex];

    entitiesData.relations.push({
      from: from.name,
      to: to.name,
      type: relType,
    });

    console.log(
      `${info("[INFO]")} Relation ajoutee : ${from.name} ${relType} ${to.name}`
    );

    const addMore = readline.keyInYNStrict("Ajouter une autre relation ?");
    if (!addMore) break;
  }
}

module.exports = { getLightModeInputs };
 */

const readline = require("readline-sync");
const { info, warning, success } = require("./colors"); // Assuming success is also imported or defined

async function getLightModeInputs(projectName, flags) {
  console.log(
    `\n${info("[LIGHT MODE]")} Simplified configuration for ${projectName}\n`
  );

  const inputs = {
    projectName,
    mode: "light",
    useYarn: false,
    packageManager: "npm",
    entitiesData: {
      entities: [],
      relations: [],
    },
  };

  const orm = getOrmChoice(flags);
  const useAuth = getAuthChoice(flags);
  const useSwagger = getSwaggerChoice(flags);
  const useDocker = getDockerChoice(flags);

  inputs.selectedDB = orm === "mongoose" ? "mongodb" : "postgresql";

  if (orm === "mongoose") {
    inputs.dbConfig = {
      orm: "mongoose",
      MONGO_URI: readline.question(
        `MongoDB URI [mongodb://localhost:27017]: `,
        {
          defaultInput: "mongodb://localhost:27017",
        }
      ),
      MONGO_DB: readline.question(`Database name [${projectName}]: `, {
        defaultInput: projectName,
      }),
    };
  } else {
    inputs.dbConfig = {
      orm,
      POSTGRES_USER: readline.question("PostgreSQL user [postgres]: ", {
        defaultInput: "postgres",
      }),
      POSTGRES_PASSWORD: readline.question("PostgreSQL password [postgres]: ", {
        defaultInput: "postgres",
        hideEchoBack: false,
      }),
      POSTGRES_DB: readline.question(`Database name [${projectName}]: `, {
        defaultInput: projectName,
      }),
      POSTGRES_HOST: readline.question("PostgreSQL host [localhost]: ", {
        defaultInput: "localhost",
      }),
      POSTGRES_PORT: readline.question("PostgreSQL port [5432]: ", {
        defaultInput: "5432",
      }),
    };
  }

  inputs.useAuth = useAuth;
  inputs.useSwagger = useSwagger;
  inputs.useDocker = useDocker;

  if (useSwagger) {
    inputs.swaggerInputs = {
      title: readline.question(`API Title [${projectName} API]: `, {
        defaultInput: `${projectName} API`,
      }),
      description: readline.question(
        "Description [API generated by NestCraftX]: ",
        {
          defaultInput: "API generated by NestCraftX",
        }
      ),
      version: readline.question("Version [1.0.0]: ", {
        defaultInput: "1.0.0",
      }),
      endpoint: readline.question("Swagger Endpoint [api/docs]: ", {
        defaultInput: "api/docs",
      }),
    };
  }

  if (useAuth) {
    console.log(
      `${info("[INFO]")} Auth active: automatically adding User entity`
    );
    inputs.entitiesData.entities.push({
      name: "user",
      fields: [
        { name: "email", type: "string" },
        { name: "password", type: "string" },
        { name: "isActive", type: "boolean" },
      ],
    });
  }

  const addEntities = readline.keyInYNStrict(
    "Do you want to add supplementary entities?"
  );
  if (addEntities) {
    console.log(`\n${info("[INFO]")} Entity input (simplified mode)`);
    await addCustomEntities(inputs.entitiesData);
  } // Demander les relations entre entitÃ©s

  if (inputs.entitiesData.entities.length > 1) {
    const wantsRelation = readline.keyInYNStrict(
      "Do you want to add relationships between entities?"
    );
    if (wantsRelation) {
      console.log(`\n${info("[INFO]")} Configuring relationships`);
      addRelations(inputs.entitiesData);
    }
  }

  return inputs;
}

function getOrmChoice(flags) {
  if (flags.orm) {
    const validOrms = ["prisma", "typeorm", "mongoose"];
    if (validOrms.includes(flags.orm)) {
      console.log(`${info("[INFO]")} ORM: ${flags.orm} (via flag)`);
      return flags.orm;
    }
  }

  let orm;
  while (true) {
    orm = readline.question(
      "Choose an ORM (prisma, typeorm, mongoose) [prisma]: ",
      {
        defaultInput: "prisma",
      }
    );
    if (["prisma", "typeorm", "mongoose"].includes(orm.toLowerCase())) {
      return orm.toLowerCase();
    }
    console.log(
      `${warning(
        "[WARNING]"
      )} Invalid ORM. Choose: prisma, typeorm, or mongoose`
    );
  }
}

function getAuthChoice(flags) {
  if (flags.auth !== undefined) {
    console.log(
      `${info("[INFO]")} Auth: ${flags.auth ? "Yes" : "No"} (via flag)`
    );
    return !!flags.auth;
  }
  return readline.keyInYNStrict("Enable JWT authentication?");
}

function getSwaggerChoice(flags) {
  if (flags.swagger !== undefined) {
    console.log(
      `${info("[INFO]")} Swagger: ${flags.swagger ? "Yes" : "No"} (via flag)`
    );
    return !!flags.swagger;
  }
  return readline.keyInYNStrict("Enable Swagger for API documentation?");
}

function getDockerChoice(flags) {
  if (flags.docker !== undefined) {
    console.log(
      `${info("[INFO]")} Docker: ${flags.docker ? "Yes" : "No"} (via flag)`
    );
    return flags.docker === true || flags.docker === "true";
  }
  return readline.keyInYNStrict("Generate Docker files?");
}

async function addCustomEntities(entitiesData) {
  while (true) {
    let name;
    while (true) {
      name = readline.question("\nEntity name (empty to finish) : ");
      if (!name) return;
      if (/^[A-Za-z][A-Za-z0-9_]*$/.test(name)) break;
      console.log(
        `${warning(
          "[WARNING]"
        )} Invalid name. Use letters, numbers, and _ only.`
      );
    }

    const fields = [];
    console.log(`Â  Fields for entity "${name}" :`);

    while (true) {
      const fieldName = readline.question(
        "Â  Â  Field name (empty to finish) : "
      );
      if (!fieldName) break;

      if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(fieldName)) {
        console.log(`${warning("[WARNING]")} Invalid field name.`);
        continue;
      } // ðŸ›‘ COMPLETE TYPE LIST (same as FULL Mode)

      const baseTypeChoices = [
        "string",
        "text",
        "number",
        "decimal",
        "boolean",
        "Date",
        "uuid",
        "json",
        "enum",
        "array",
        "object",
      ];

      const typeQuestion = {
        type: "list",
        name: "ftype",
        message: `Type of "${fieldName}"`,
        default: "string",
        choices: baseTypeChoices,
      };

      const typeAnswer = await actualInquirer.prompt([typeQuestion]);
      let fieldType = typeAnswer.ftype; // --- ADVANCED LOGIC FOR ARRAY, ENUM, AND OBJECT ---

      if (fieldType === "array") {
        // Prompt spÃ©cifique pour le type interne du tableau
        const arrayInnerQuestion = {
          type: "list",
          name: "innerType",
          message: `Type of elements in "${fieldName}[]"`,
          default: "string", // Exclure array et object du sous-type pour simplifier
          choices: baseTypeChoices.filter(
            (c) => c !== "array" && c !== "object"
          ),
        };

        const innerAnswer = await actualInquirer.prompt([arrayInnerQuestion]);
        fieldType = `${innerAnswer.innerType}[]`;
      } else if (fieldType === "enum") {
        const enumName = capitalize(fieldName) + "Enum";
        console.log(
          `Â  Â  ${info(
            "[INFO]"
          )} Enum type selected. Remember to define ${enumName} in your code.`
        );
        fieldType = enumName;
      } else if (fieldType === "object") {
        // Prompt pour nommer l'objet (ou 'json' par dÃ©faut)
        const objectNameQuestion = {
          type: "input",
          name: "objectName",
          message: `Complex type name (DTO/Class or leave 'json') :`,
          default: "json",
        };

        const objectAnswer = await actualInquirer.prompt([objectNameQuestion]);
        fieldType = capitalize(objectAnswer.objectName.trim() || "json");
      } // ðŸŸ¢ CLEAN AND ALIGNED DISPLAY

      console.log(
        `Â  Â  Field type for "${fieldName}" : ${fieldType} ${success("[âœ“]")}`
      );

      fields.push({ name: fieldName, type: fieldType });
    }

    if (fields.length > 0) {
      entitiesData.entities.push({ name, fields });
      console.log(
        `${info("[INFO]")} Entity "${name}" added with ${
          fields.length
        } field(s)`
      );
    }

    const addMore = readline.keyInYNStrict("Add another entity?");
    if (!addMore) break;
  }
}

function addRelations(entitiesData) {
  while (true) {
    console.log("\n Â Available entities:");
    entitiesData.entities.forEach((ent, index) =>
      console.log(` Â  Â [${index}] ${ent.name}`)
    );

    let fromIndex, toIndex;
    while (true) {
      fromIndex = parseInt(
        readline.question(" Â From which entity? (index) : "),
        10
      );
      if (!isNaN(fromIndex) && entitiesData.entities[fromIndex]) break;
      console.log(`${warning("[WARNING]")} Invalid index.`);
    }
    while (true) {
      toIndex = parseInt(
        readline.question(" Â To which entity? (index) : "),
        10
      );
      if (!isNaN(toIndex) && entitiesData.entities[toIndex]) break;
      console.log(`${warning("[WARNING]")} Invalid index.`);
    }

    let relType;
    while (true) {
      relType = readline.question(
        " Â Relationship type (1-1 / 1-n / n-1 / n-n) : "
      );
      if (["1-1", "1-n", "n-1", "n-n"].includes(relType)) break;
      console.log(
        `${warning("[WARNING]")} Invalid type. Choose: 1-1, 1-n, n-1, n-n`
      );
    }

    const from = entitiesData.entities[fromIndex];
    const to = entitiesData.entities[toIndex];

    entitiesData.relations.push({
      from: from.name,
      to: to.name,
      type: relType,
    });

    console.log(
      `${info("[INFO]")} Relationship added: ${from.name} ${relType} ${to.name}`
    );

    const addMore = readline.keyInYNStrict("Add another relationship?");
    if (!addMore) break;
  }
}

module.exports = { getLightModeInputs };
