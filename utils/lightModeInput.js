const readline = require("readline-sync");
const { info, warning, success } = require("./colors");
const inquirer = require("inquirer");
const { question } = require("readline-sync");
const { capitalize } = require("./userInput");
const { logWarning } = require("./loggers/logWarning");
const { logInfo } = require("./loggers/logInfo");
const { getPackageManager } = require("./utils");
const actualInquirer = inquirer.default || inquirer;

async function getLightModeInputs(projectName, flags) {
  console.log(
    `\n${info("[LIGHT MODE]")} Simplified configuration for ${projectName}\n`
  );

  const inputs = {
    projectName,
    mode: "light",
    selectedDB: "postgresql",
    packageManager: "npm",
    entitiesData: {
      entities: [],
      relations: [],
    },
  };

  // db config
  const orm = await getOrmChoice(flags);
  inputs.selectedDB = orm === "mongoose" ? "mongodb" : "postgresql";

  if (orm === "mongoose") {
    logInfo("MongoDB configuration");
    inputs.dbConfig = {
      orm,
      MONGO_URI: readline.question(
        `MongoDB URI [mongodb://localhost:27017]: `,
        {
          defaultInput: "mongodb://localhost:27017",
        }
      ),
      MONGO_DB: readline.question(`Database name [${projectName}-db]: `, {
        defaultInput: `${projectName}-db`,
      }),
    };
  } else {
    logInfo("PostgreSQL configuration");
    inputs.dbConfig = {
      orm,
      POSTGRES_USER: readline.question("PostgreSQL user [postgres]: ", {
        defaultInput: "postgres",
      }),
      POSTGRES_PASSWORD: readline.question("PostgreSQL password [postgres]: ", {
        defaultInput: "postgres",
        hideEchoBack: true,
      }),
      POSTGRES_DB: readline.question(`Database name [${projectName}-db]: `, {
        defaultInput: `${projectName}-db`,
      }),
      POSTGRES_HOST: readline.question("PostgreSQL host [localhost]: ", {
        defaultInput: "localhost",
      }),
      POSTGRES_PORT: readline.question("PostgreSQL port [5432]: ", {
        defaultInput: "5432",
      }),
    };
  }

  // swagger config
  const useSwagger = getSwaggerChoice(flags);
  if (useSwagger) {
    inputs.swaggerInputs = {
      title: readline.question(`API Title [${projectName} API]: `, {
        defaultInput: `${projectName} API`,
      }),
      description: readline.question(
        "Description [API generated by NestCraftX]: ",
        {
          defaultInput: "API generated by NestCraftX",
        }
      ),
      version: readline.question("Version [1.0.0]: ", {
        defaultInput: "1.0.0",
      }),
      endpoint: readline.question("Swagger Endpoint [api/docs]: ", {
        defaultInput: "api/docs",
      }),
    };
  }

  // Docker config
  const useDocker = getDockerChoice(flags);

  // JWT Auth config
  const useAuth = getAuthChoice(flags);

  const packageManager = await getPackageManager(flags);
  inputs.packageManager = packageManager;

  inputs.useAuth = useAuth;
  inputs.useSwagger = useSwagger;
  inputs.useDocker = useDocker;

  if (useAuth) {
    console.log(
      `${info("[INFO]")} Auth active: adding User and Session entities`
    );

    // 1. Entité User
    inputs.entitiesData.entities.push({
      name: "user",
      fields: [
        { name: "email", type: "string", unique: true },
        { name: "password", type: "string" },
        { name: "role", type: "Role" },
        { name: "isActive", type: "boolean", default: true },
      ],
    });

    // 2. Entité Session
    inputs.entitiesData.entities.push({
      name: "session",
      fields: [
        { name: "refreshToken", type: "string" },
        { name: "userId", type: "string" },
        { name: "expiresAt", type: "Date" },
        { name: "createdAt", type: "Date", default: "now" },
      ],
    });
    // 3. relation user & session
    inputs.entitiesData.relations.push({
      from: "user",
      to: "session",
      type: "1-n",
    });
  }

  const addEntities = readline.keyInYNStrict(
    `${info("[?]")} Do you want to add supplementary entities ?`
  );
  if (addEntities) {
    console.log(`\n${info("[INFO]")} Entity input (simplified mode)`);
    await addCustomEntities(inputs.entitiesData);
  }

  // Demander les relations entre entités
  if (inputs.entitiesData.entities.length > 1) {
    const wantsRelation = readline.keyInYNStrict(
      `${info("[?]")} Do you want to add relationships between entities ?`
    );
    if (wantsRelation) {
      console.log(`\n${info("[INFO]")} Configuring relationships`);
      await addRelations(inputs.entitiesData);
    }
  }

  return inputs;
}

async function getOrmChoice(flags) {
  const validOrms = ["prisma", "typeorm", "mongoose"];

  // 1. Vérification du flag
  if (flags.orm && validOrms.includes(flags.orm.toLowerCase())) {
    console.log(`${info("[INFO]")} ORM: ${flags.orm} (via flag)`);
    return flags.orm.toLowerCase();
  }

  // 2. Mode interactif avec Inquirer
  const answers = await actualInquirer.prompt([
    {
      type: "list",
      name: "orm",
      message: "Choose an ORM:",
      choices: [
        { name: "Prisma (PostgreSQL)", value: "prisma" },
        { name: "TypeORM (PostgreSQL)", value: "typeorm" },
        { name: "Mongoose (MongoDB)", value: "mongoose" },
      ],
      default: "prisma",
    },
  ]);

  return answers.orm;
}

function getAuthChoice(flags) {
  if (flags.auth !== undefined) {
    logInfo(`Auth: ${flags.auth ? "Yes" : "No"} (via flag)`);
    return !!flags.auth;
  }
  return readline.keyInYNStrict(`${info("[?]")} Enable JWT authentication ?`);
}

function getSwaggerChoice(flags) {
  if (flags.swagger !== undefined) {
    console.log(
      `${info("[INFO]")} Swagger: ${flags.swagger ? "Yes" : "No"} (via flag)`
    );
    return !!flags.swagger;
  }
  return readline.keyInYNStrict(
    `${info("[?]")} Enable Swagger for API documentation ?`
  );
}

function getDockerChoice(flags) {
  if (flags.docker !== undefined) {
    console.log(
      `${info("[INFO]")} Docker: ${flags.docker ? "Yes" : "No"} (via flag)`
    );
    return flags.docker === true || flags.docker === "true";
  }
  return readline.keyInYNStrict(`${info("[?]")} Generate Docker files ?`);
}

async function addCustomEntities(entitiesData) {
  while (true) {
    let name;
    while (true) {
      name = readline.question("\nEntity name (empty to finish) : ");
      if (!name) return;
      if (/^[A-Za-z][A-Za-z0-9_]*$/.test(name)) break;
      logWarning("Invalid name. Use letters, numbers, and _ only.");
    }

    const fields = [];
    console.log(` Fields for entity "${name}" :`);

    while (true) {
      const fieldName = readline.question("  Field name (empty to finish) : ");
      if (!fieldName) break;

      if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(fieldName)) {
        logWarning("Invalid field name.");
        continue;
      }

      const baseTypeChoices = [
        "string",
        "text",
        "number",
        "decimal",
        "boolean",
        "Date",
        "uuid",
        "json",
        "enum",
        "array",
        "object",
      ];

      const typeQuestion = {
        type: "list",
        name: "ftype",
        message: `Type of "${fieldName}"`,
        default: "string",
        choices: baseTypeChoices,
      };

      const typeAnswer = await actualInquirer.prompt([typeQuestion]);
      let fieldType = typeAnswer.ftype; // --- ADVANCED LOGIC FOR ARRAY, ENUM, AND OBJECT ---
      // Déplace le curseur d'une ligne vers le haut :
      process.stdout.write("\x1B[1A");
      // Efface la ligne (où se trouvait le "√ Type for...") :
      process.stdout.write("\x1B[K");

      if (fieldType === "array") {
        // Prompt spécifique pour le type interne du tableau
        const arrayInnerQuestion = {
          type: "list",
          name: "innerType",
          message: `Type of elements in "${fieldName}[]"`,
          default: "string", // Exclure array et object du sous-type pour simplifier
          choices: baseTypeChoices.filter(
            (c) => c !== "array" && c !== "object"
          ),
        };

        const innerAnswer = await actualInquirer.prompt([arrayInnerQuestion]);
        fieldType = `${innerAnswer.innerType}[]`;
      } else if (fieldType === "enum") {
        const enumName = capitalize(fieldName) + "Enum";
        logInfo(
          `Enum type selected. Remember to define ${enumName} in your code.`
        );
        fieldType = enumName;
      } else if (fieldType === "object") {
        // Prompt pour nommer l'objet (ou 'json' par défaut)
        const objectNameQuestion = {
          type: "input",
          name: "objectName",
          message: `Complex type name (DTO/Class or leave 'json') :`,
          default: "json",
        };

        const objectAnswer = await actualInquirer.prompt([objectNameQuestion]);
        fieldType = capitalize(objectAnswer.objectName.trim() || "json");
      }

      console.log(
        `  Field type for "${fieldName}" : ${fieldType} ${success("[✓]")}`
      );

      fields.push({ name: fieldName, type: fieldType });
    }

    if (fields.length > 0) {
      entitiesData.entities.push({ name, fields });
      console.log(
        `${info("[INFO]")} Entity "${name}" added with ${
          fields.length
        } field(s)`
      );
    }

    const addMore = readline.keyInYNStrict("Add another entity?");
    if (!addMore) break;
  }
}

/**
 * Manages adding relationships between entities via an interactive interface.
 * All prompts and logs are in English.
 * @param {Object} entitiesData - The object containing entities and relations.
 */
async function addRelations(entitiesData) {
  if (entitiesData.entities.length < 2) {
    logInfo("At least two entities are required to create a relationship.");
    return;
  }

  let configuring = true;

  while (configuring) {
    const entityNames = entitiesData.entities.map((e) => e.name);

    // 1. Interactive selection of entities
    const answers = await actualInquirer.prompt([
      {
        type: "list",
        name: "fromName",
        message: "Select the source entity (From) :",
        choices: entityNames,
      },
      {
        type: "list",
        name: "toName",
        message: (prev) =>
          `To which entity do you want to link ${prev.fromName} ?`,
        choices: (prev) => entityNames.filter((name) => name !== prev.fromName),
      },
    ]);

    // --- CHECK FOR EXISTING RELATIONSHIPS ---
    const alreadyExists = entitiesData.relations.find(
      (rel) =>
        (rel.from === answers.fromName && rel.to === answers.toName) ||
        (rel.from === answers.toName && rel.to === answers.fromName)
    );

    if (alreadyExists) {
      logWarning(
        `A relationship already exists between ${answers.fromName} and ${answers.toName} (${alreadyExists.type}).`
      );

      const { tryAgain } = await actualInquirer.prompt([
        {
          type: "confirm",
          name: "tryAgain",
          message: "Would you like to choose different entities ?",
          default: true,
        },
      ]);

      if (!tryAgain) break;
      // Restart the loop
      continue;
    }

    // 2. Select Relationship Type
    const typeAnswer = await actualInquirer.prompt([
      {
        type: "list",
        name: "relType",
        message: "What is the relationship type?",
        choices: [
          {
            name: `1-1 (One-to-One)   : ${answers.fromName} is linked to exactly one ${answers.toName}`,
            value: "1-1",
          },
          {
            name: `1-n (One-to-Many)  : ${answers.fromName} owns multiple ${answers.toName}s`,
            value: "1-n",
          },
          {
            name: `n-1 (Many-to-One)  : Multiple ${answers.fromName}s belong to one ${answers.toName}`,
            value: "n-1",
          },
          {
            name: `n-n (Many-to-Many) : Multiple ${answers.fromName}s are linked to multiple ${answers.toName}s`,
            value: "n-n",
          },
        ],
      },
    ]);

    const from = entitiesData.entities.find((e) => e.name === answers.fromName);
    const to = entitiesData.entities.find((e) => e.name === answers.toName);
    const relType = typeAnswer.relType;

    // 3. Register relationship
    entitiesData.relations.push({
      from: from.name,
      to: to.name,
      type: relType,
    });

    // 4. Automatic field injection
    const fromLow = from.name.toLowerCase();
    const toLow = to.name.toLowerCase();
    if (relType === "1-1") {
      from.fields.push(
        { name: `${toLow}Id`, type: "string" },
        { name: toLow, type: to.name }
      );
    } else if (relType === "1-n") {
      from.fields.push({ name: `${toLow}s`, type: `${to.name}[]` });
      to.fields.push(
        { name: `${fromLow}Id`, type: "string" },
        { name: fromLow, type: from.name }
      );
    } else if (relType === "n-1") {
      from.fields.push(
        { name: `${toLow}Id`, type: "string" },
        { name: toLow, type: to.name }
      );
      to.fields.push({ name: `${fromLow}s`, type: `${from.name}[]` });
    } else if (relType === "n-n") {
      from.fields.push({ name: `${toLow}s`, type: `${to.name}[]` });
      to.fields.push({ name: `${fromLow}s`, type: `${from.name}[]` });
    }
    console.log(
      `${success("[✓]")} Relationship added: ${from.name} ${relType} ${to.name}`
    );

    // 5. Ask to continue
    const { addMore } = await actualInquirer.prompt([
      {
        type: "confirm",
        name: "addMore",
        message: "Do you want to add another relationship ?",
        default: false,
      },
    ]);

    configuring = addMore;
  }
}

module.exports = { getLightModeInputs };
