const readline = require('readline-sync');
const { info, warning } = require('./colors');

function getLightModeInputs(projectName, flags) {
  console.log(`\n${info('[MODE LIGHT]')} Configuration simplifiee pour ${projectName}\n`);

  const inputs = {
    projectName,
    mode: 'light',
    useYarn: false,
    packageManager: 'npm',
    entitiesData: {
      entities: [],
      relations: []
    }
  };

  const orm = getOrmChoice(flags);
  const useAuth = getAuthChoice(flags);
  const useSwagger = getSwaggerChoice(flags);
  const useDocker = getDockerChoice(flags);

  inputs.selectedDB = orm === 'mongoose' ? 'mongodb' : 'postgresql';

  if (orm === 'mongoose') {
    inputs.dbConfig = {
      orm: 'mongoose',
      MONGO_URI: readline.question(`URI MongoDB [mongodb://localhost:27017]: `, {
        defaultInput: 'mongodb://localhost:27017'
      }),
      MONGO_DB: readline.question(`Nom de la base [${projectName}]: `, {
        defaultInput: projectName
      })
    };
  } else {
    inputs.dbConfig = {
      orm,
      POSTGRES_USER: readline.question('Utilisateur PostgreSQL [postgres]: ', {
        defaultInput: 'postgres'
      }),
      POSTGRES_PASSWORD: readline.question('Mot de passe PostgreSQL [postgres]: ', {
        defaultInput: 'postgres',
        hideEchoBack: false
      }),
      POSTGRES_DB: readline.question(`Nom de la base [${projectName}]: `, {
        defaultInput: projectName
      }),
      POSTGRES_HOST: readline.question('Hote PostgreSQL [localhost]: ', {
        defaultInput: 'localhost'
      }),
      POSTGRES_PORT: readline.question('Port PostgreSQL [5432]: ', {
        defaultInput: '5432'
      })
    };
  }

  inputs.useAuth = useAuth;
  inputs.useSwagger = useSwagger;
  inputs.useDocker = useDocker;

  if (useSwagger) {
    inputs.swaggerInputs = {
      title: readline.question(`Titre API [${projectName} API]: `, {
        defaultInput: `${projectName} API`
      }),
      description: readline.question('Description [API generated by NestCraftX]: ', {
        defaultInput: 'API generated by NestCraftX'
      }),
      version: readline.question('Version [1.0.0]: ', {
        defaultInput: '1.0.0'
      }),
      endpoint: readline.question('Endpoint Swagger [api/docs]: ', {
        defaultInput: 'api/docs'
      })
    };
  }

  if (useAuth) {
    console.log(`${info('[INFO]')} Auth active : ajout automatique de l'entite User`);
    inputs.entitiesData.entities.push({
      name: 'user',
      fields: [
        { name: 'email', type: 'string' },
        { name: 'password', type: 'string' },
        { name: 'isActive', type: 'boolean' }
      ]
    });
  }

  const addEntities = readline.keyInYNStrict('Voulez-vous ajouter des entites supplementaires ?');
  if (addEntities) {
    console.log(`\n${info('[INFO]')} Saisie des entites (mode simplifie)`);
    addCustomEntities(inputs.entitiesData);
  }

  // Demander les relations entre entitÃ©s
  if (inputs.entitiesData.entities.length > 1) {
    const wantsRelation = readline.keyInYNStrict('Voulez-vous ajouter des relations entre entites ?');
    if (wantsRelation) {
      console.log(`\n${info('[INFO]')} Configuration des relations`);
      addRelations(inputs.entitiesData);
    }
  }

  return inputs;
}

function getOrmChoice(flags) {
  if (flags.orm) {
    const validOrms = ['prisma', 'typeorm', 'mongoose'];
    if (validOrms.includes(flags.orm)) {
      console.log(`${info('[INFO]')} ORM : ${flags.orm} (via flag)`);
      return flags.orm;
    }
  }

  let orm;
  while (true) {
    orm = readline.question('Choisissez un ORM (prisma, typeorm, mongoose) [prisma]: ', {
      defaultInput: 'prisma'
    });
    if (['prisma', 'typeorm', 'mongoose'].includes(orm.toLowerCase())) {
      return orm.toLowerCase();
    }
    console.log(`${warning('[WARNING]')} ORM invalide. Choisissez : prisma, typeorm ou mongoose`);
  }
}

function getAuthChoice(flags) {
  if (flags.auth !== undefined) {
    console.log(`${info('[INFO]')} Auth : ${flags.auth ? 'Oui' : 'Non'} (via flag)`);
    return !!flags.auth;
  }
  return readline.keyInYNStrict('Activer l\'authentification JWT ?');
}

function getSwaggerChoice(flags) {
  if (flags.swagger !== undefined) {
    console.log(`${info('[INFO]')} Swagger : ${flags.swagger ? 'Oui' : 'Non'} (via flag)`);
    return !!flags.swagger;
  }
  return readline.keyInYNStrict('Activer Swagger pour la documentation API ?');
}

function getDockerChoice(flags) {
  if (flags.docker !== undefined) {
    console.log(`${info('[INFO]')} Docker : ${flags.docker ? 'Oui' : 'Non'} (via flag)`);
    return flags.docker === true || flags.docker === 'true';
  }
  return readline.keyInYNStrict('Generer les fichiers Docker ?');
}

function addCustomEntities(entitiesData) {
  while (true) {
    let name;
    while (true) {
      name = readline.question('\nNom de l\'entite (vide pour terminer) : ');
      if (!name) return;
      if (/^[A-Za-z][A-Za-z0-9_]*$/.test(name)) break;
      console.log(`${warning('[WARNING]')} Nom invalide. Utilisez lettres, chiffres et _ uniquement.`);
    }

    const fields = [];
    console.log(`  Champs pour l'entite "${name}" :`);

    while (true) {
      const fieldName = readline.question('    Nom du champ (vide pour terminer) : ');
      if (!fieldName) break;

      if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(fieldName)) {
        console.log(`${warning('[WARNING]')} Nom de champ invalide.`);
        continue;
      }

      let fieldType;
      while (true) {
        fieldType = readline.question(`    Type du champ "${fieldName}" (string, number, boolean, Date) : `);
        if (fieldType && ['string', 'number', 'boolean', 'Date'].includes(fieldType)) break;
        console.log(`${warning('[WARNING]')} Type invalide. Choisissez : string, number, boolean, Date`);
      }

      fields.push({ name: fieldName, type: fieldType });
    }

    if (fields.length > 0) {
      entitiesData.entities.push({ name, fields });
      console.log(`${info('[INFO]')} Entite "${name}" ajoutee avec ${fields.length} champ(s)`);
    }

    const addMore = readline.keyInYNStrict('Ajouter une autre entite ?');
    if (!addMore) break;
  }
}

function addRelations(entitiesData) {
  while (true) {
    console.log("\n  Entites disponibles :");
    entitiesData.entities.forEach((ent, index) =>
      console.log(`    [${index}] ${ent.name}`)
    );

    let fromIndex, toIndex;
    while (true) {
      fromIndex = parseInt(
        readline.question("  Depuis quelle entite ? (index) : "),
        10
      );
      if (!isNaN(fromIndex) && entitiesData.entities[fromIndex]) break;
      console.log(`${warning('[WARNING]')} Indice invalide.`);
    }
    while (true) {
      toIndex = parseInt(
        readline.question("  Vers quelle entite ? (index) : "),
        10
      );
      if (!isNaN(toIndex) && entitiesData.entities[toIndex]) break;
      console.log(`${warning('[WARNING]')} Indice invalide.`);
    }

    let relType;
    while (true) {
      relType = readline.question("  Type de relation (1-1 / 1-n / n-n) : ");
      if (["1-1", "1-n", "n-1", "n-n"].includes(relType)) break;
      console.log(`${warning('[WARNING]')} Type invalide. Choisissez : 1-1, 1-n, n-1, n-n`);
    }

    const from = entitiesData.entities[fromIndex];
    const to = entitiesData.entities[toIndex];

    entitiesData.relations.push({
      from: from.name,
      to: to.name,
      type: relType,
    });

    console.log(`${info('[INFO]')} Relation ajoutee : ${from.name} ${relType} ${to.name}`);

    const addMore = readline.keyInYNStrict('Ajouter une autre relation ?');
    if (!addMore) break;
  }
}

module.exports = { getLightModeInputs };
