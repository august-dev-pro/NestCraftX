const readline = require("readline-sync");
const { info, success, warning } = require("./colors");

/* async function getFullModeInputs(projectName, flags) {
  console.log(
    `\n${info("[MODE FULL]")} Configuration complete avec Clean Architecture\n`
  );

  const dataBases = [
    {
      name: "postgresql",
      label: "PostgreSQL",
      ormOptions: ["prisma", "typeorm"],
      required: [
        {
          title: "Utilisateur PostgreSQL",
          envVar: "POSTGRES_USER",
          defaultValue: "postgres",
          hideEchoBack: false,
        },
        {
          title: "Mot de passe PostgreSQL",
          envVar: "POSTGRES_PASSWORD",
          defaultValue: "postgres",
          hideEchoBack: false,
        },
        {
          title: "Nom de la base",
          envVar: "POSTGRES_DB",
          defaultValue: "mydb",
          hideEchoBack: false,
        },
        {
          title: "Hote PostgreSQL",
          envVar: "POSTGRES_HOST",
          defaultValue: "localhost",
          hideEchoBack: false,
        },
        {
          title: "Port PostgreSQL",
          envVar: "POSTGRES_PORT",
          defaultValue: "5432",
          hideEchoBack: false,
        },
      ],
    },
    {
      name: "mongodb",
      label: "MongoDB",
      ormOptions: ["mongoose"],
      required: [
        {
          title: "URI MongoDB",
          envVar: "MONGO_URI",
          defaultValue: "mongodb://localhost:27017",
          hideEchoBack: false,
        },
        {
          title: "Nom de la base",
          envVar: "MONGO_DB",
          defaultValue: "mydb",
          hideEchoBack: false,
        },
      ],
    },
  ];

  let projectName = projectName;
  while (true) {
    if (/^[A-Za-z][A-Za-z0-9_-]*$/.test(projectName)) break;
    projectName = readline.question(`${info("[?]")} Nom du projet : `);

    console.log(
      `${warning(
        "[!]"
      )} Nom invalide. Utilisez lettres, chiffres, _ ou - (commencez par une lettre).`
    );
  }

  let usedDB = readline.question(
    `${info("[?]")} Base de donnees (postgresql, mongodb) [postgresql] : `,
    { defaultInput: "postgresql" }
  );
  let selectedDB = dataBases.find(
    (db) => db.name.toLowerCase() === usedDB.toLowerCase()
  );
  while (!selectedDB) {
    console.log(`${warning("[!]")} Base de donnees non reconnue.`);
    usedDB = readline.question(
      `${info("[?]")} Base de donnees (postgresql, mongodb) : `
    );
    selectedDB = dataBases.find(
      (db) => db.name.toLowerCase() === usedDB.toLowerCase()
    );
  }

  const dbConfig = {};
  console.log(`\n${info("[INFO]")} Configuration ${selectedDB.label}`);
  selectedDB.required.forEach((field) => {
    let answer;
    while (true) {
      answer = readline.question(
        `  ${field.title} [${field.defaultValue}] : `,
        { hideEchoBack: field.hideEchoBack }
      );
      if (answer || field.defaultValue !== null) break;
      console.log(`${warning("[!]")} Ce champ est requis.`);
    }
    dbConfig[field.envVar] = answer || field.defaultValue;
  });

  if (selectedDB.ormOptions && selectedDB.ormOptions.length > 0) {
    let ormChoice;
    while (true) {
      ormChoice = readline.question(
        `${info("[?]")} ORM pour ${
          selectedDB.label
        } (${selectedDB.ormOptions.join(", ")}) [${
          selectedDB.ormOptions[0]
        }] : `
      );
      if (!ormChoice) ormChoice = selectedDB.ormOptions[0];
      if (selectedDB.ormOptions.includes(ormChoice.toLowerCase())) break;
      console.log(
        `${warning(
          "[!]"
        )} ORM non reconnu. Choisissez : ${selectedDB.ormOptions.join(", ")}`
      );
    }
    dbConfig.orm = ormChoice.toLowerCase();
  }

  const useYarn = readline.keyInYNStrict(`${info("[?]")} Utiliser Yarn ?`);
  const useDocker = readline.keyInYNStrict(
    `${info("[?]")} Generer fichiers Docker ?`
  );
  const useAuth = readline.keyInYNStrict(
    `${info("[?]")} Ajouter authentification JWT ?`
  );
  const useSwagger = readline.keyInYNStrict(
    `${info("[?]")} Installer Swagger ?`
  );
  const packageManager = useYarn ? "yarn" : "npm";

  const entitiesData = {
    entities: [],
    relations: [],
  };

  let swaggerInputs;
  if (useSwagger) {
    console.log(`\n${info("[INFO]")} Configuration Swagger`);
    swaggerInputs = {
      title: readline.question(`  Titre API [${projectName} API] : `, {
        defaultInput: `${projectName} API`,
      }),
      description: readline.question(
        "  Description [API generated by NestCraftX] : ",
        {
          defaultInput: "API generated by NestCraftX",
        }
      ),
      version: readline.question("  Version [1.0.0] : ", {
        defaultInput: "1.0.0",
      }),
      endpoint: readline.question("  Endpoint [api/docs] : ", {
        defaultInput: "api/docs",
      }),
    };
  }

  if (useAuth) {
    console.log(
      `\n${success("[✓]")} Auth active : entite User ajoutee automatiquement`
    );
    entitiesData.entities.push({
      name: "user",
      fields: [
        { name: "email", type: "string" },
        { name: "password", type: "string" },
        { name: "isActive", type: "boolean" },
      ],
    });
  }

  console.log(
    `\n${info("[INFO]")} Saisie des entites (Mode FULL - Architecture complete)`
  );
  let addEntity = readline.keyInYNStrict(`${info("[?]")} Ajouter une entite ?`);
  while (addEntity) {
    let name;
    while (true) {
      name = readline.question(`\n  Nom de l'entite : `);
      if (/^[A-Za-z][A-Za-z0-9_]*$/.test(name)) break;
      console.log(
        `${warning(
          "[!]"
        )} Nom invalide. Lettres, chiffres, _ (commencez par une lettre).`
      );
    }

    const fields = [];
    console.log(`  Champs pour "${name}" :`);
    while (true) {
      let fname = readline.question("    Nom du champ (vide pour terminer) : ");
      if (!fname) break;
      if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(fname)) {
        console.log(`${warning("[!]")} Nom de champ invalide.`);
        continue;
      }
      let ftype;
      while (true) {
        ftype = readline.question(
          `    Type de "${fname}" (string, number, boolean, Date, enum) : `
        );
        if (ftype) break;
        console.log(`${warning("[!]")} Type requis.`);
      }
      fields.push({ name: fname, type: ftype });
    }

    entitiesData.entities.push({ name, fields });
    console.log(
      `${success("[✓]")} Entite "${name}" ajoutee avec ${
        fields.length
      } champ(s)`
    );

    addEntity = readline.keyInYNStrict(
      `${info("[?]")} Ajouter une autre entite ?`
    );
  }

  const wantsRelation = readline.keyInYNStrict(
    `${info("[?]")} Ajouter des relations entre entites ?`
  );
  if (wantsRelation && entitiesData.entities.length > 1) {
    console.log(`\n${info("[INFO]")} Configuration des relations`);
    while (true) {
      console.log("\n  Entites disponibles :");
      entitiesData.entities.forEach((ent, index) =>
        console.log(`    [${index}] ${ent.name}`)
      );

      let fromIndex, toIndex;
      while (true) {
        fromIndex = parseInt(
          readline.question("  Depuis quelle entite ? (index) : "),
          10
        );
        if (!isNaN(fromIndex) && entitiesData.entities[fromIndex]) break;
        console.log(`${warning("[!]")} Indice invalide.`);
      }
      while (true) {
        toIndex = parseInt(
          readline.question("  Vers quelle entite ? (index) : "),
          10
        );
        if (!isNaN(toIndex) && entitiesData.entities[toIndex]) break;
        console.log(`${warning("[!]")} Indice invalide.`);
      }

      let relType;
      while (true) {
        relType = readline.question("  Type de relation (1-1 / 1-n / n-n) : ");
        if (["1-1", "1-n", "n-n"].includes(relType)) break;
        console.log(
          `${warning("[!]")} Type invalide. Choisissez : 1-1, 1-n, n-n`
        );
      }

      const from = entitiesData.entities[fromIndex];
      const to = entitiesData.entities[toIndex];

      entitiesData.relations.push({
        from: from.name,
        to: to.name,
        type: relType,
      });

      console.log(
        `${success("[✓]")} Relation ajoutee : ${from.name} ${relType} ${
          to.name
        }`
      );

      if (relType === "1-1") {
        from.fields.push({
          name: `${to.name.toLowerCase()}Id`,
          type: "string",
        });
      } else if (relType === "1-n") {
        from.fields.push({
          name: `${to.name.toLowerCase()}s`,
          type: `${to.name}[]`,
        });
      } else if (relType === "n-n") {
        from.fields.push({
          name: `${to.name.toLowerCase()}s`,
          type: `${to.name}[]`,
        });
        to.fields.push({
          name: `${from.name.toLowerCase()}s`,
          type: `${from.name}[]`,
        });
      }

      const addMore = readline.keyInYNStrict(
        `${info("[?]")} Ajouter une autre relation ?`
      );
      if (!addMore) break;
    }
  }

  return {
    projectName,
    useYarn,
    useDocker,
    useAuth,
    useSwagger,
    swaggerInputs,
    packageManager,
    entitiesData,
    selectedDB: selectedDB.name,
    dbConfig,
    mode: "full",
  };
} */

async function getFullModeInputs(projectName, flags) {
  console.log(
    `\n${info("[MODE FULL]")} Configuration complete avec Clean Architecture\n`
  );

  const dataBases = [
    {
      name: "postgresql",
      label: "PostgreSQL",
      ormOptions: ["prisma", "typeorm"],
      required: [
        {
          title: "Utilisateur PostgreSQL",
          envVar: "POSTGRES_USER",
          defaultValue: "postgres",
          hideEchoBack: false,
        },
        {
          title: "Mot de passe PostgreSQL",
          envVar: "POSTGRES_PASSWORD",
          defaultValue: "postgres",
          hideEchoBack: false,
        },
        {
          title: "Nom de la base",
          envVar: "POSTGRES_DB",
          defaultValue: "mydb",
          hideEchoBack: false,
        },
        {
          title: "Hote PostgreSQL",
          envVar: "POSTGRES_HOST",
          defaultValue: "localhost",
          hideEchoBack: false,
        },
        {
          title: "Port PostgreSQL",
          envVar: "POSTGRES_PORT",
          defaultValue: "5432",
          hideEchoBack: false,
        },
      ],
    },
    {
      name: "mongodb",
      label: "MongoDB",
      ormOptions: ["mongoose"],
      required: [
        {
          title: "URI MongoDB",
          envVar: "MONGO_URI",
          defaultValue: "mongodb://localhost:27017",
          hideEchoBack: false,
        },
        {
          title: "Nom de la base",
          envVar: "MONGO_DB",
          defaultValue: "mydb",
          hideEchoBack: false,
        },
      ],
    },
  ];

  let currentProjectName = projectName;
  while (true) {
    if (/^[A-Za-z][A-Za-z0-9_-]*$/.test(currentProjectName)) break;
    currentProjectName = readline.question(`${info("[?]")} Nom du projet : `);
    console.log(
      `${warning(
        "[!]"
      )} Nom invalide. Utilisez lettres, chiffres, _ ou - (commencez par une lettre).`
    );
  }

  // --- 1. Base de Données ---
  const defaultDB = getFlagValue(flags, "db", "postgresql");
  let usedDB = readline.question(
    `${info("[?]")} Base de donnees (postgresql, mongodb) [${defaultDB}] : `,
    { defaultInput: defaultDB }
  );
  let selectedDB = dataBases.find(
    (db) => db.name.toLowerCase() === usedDB.toLowerCase()
  );
  while (!selectedDB) {
    console.log(`${warning("[!]")} Base de donnees non reconnue.`);
    usedDB = readline.question(
      `${info("[?]")} Base de donnees (postgresql, mongodb) : `
    );
    selectedDB = dataBases.find(
      (db) => db.name.toLowerCase() === usedDB.toLowerCase()
    );
  }

  // --- 2. Configuration DB (Utilisation des flags) ---
  const dbConfig = {};
  console.log(`\n${info("[INFO]")} Configuration ${selectedDB.label}`);

  selectedDB.required.forEach((field) => {
    // Détermine la clé de flag (ex: 'dbUser' pour POSTGRES_USER ou 'mongoUri' pour MONGO_URI)
    const flagName = field.envVar
      .toLowerCase()
      .replace("postgres_", "db")
      .replace("mongo_", "mongo");
    const defaultValue = getFlagValue(flags, flagName, field.defaultValue);

    let answer;
    while (true) {
      answer = readline.question(`  ${field.title} [${defaultValue}] : `, {
        hideEchoBack: field.hideEchoBack,
      });
      if (answer || defaultValue !== null) break;
      console.log(`${warning("[!]")} Ce champ est requis.`);
    }
    dbConfig[field.envVar] = answer || defaultValue;
  });

  // --- 3. ORM ---
  if (selectedDB.ormOptions && selectedDB.ormOptions.length > 0) {
    const defaultOrm = getFlagValue(flags, "orm", selectedDB.ormOptions[0]);
    let ormChoice;
    while (true) {
      ormChoice = readline.question(
        `${info("[?]")} ORM pour ${
          selectedDB.label
        } (${selectedDB.ormOptions.join(", ")}) [${defaultOrm}] : `
      );
      if (!ormChoice) ormChoice = defaultOrm;
      if (selectedDB.ormOptions.includes(ormChoice.toLowerCase())) break;
      console.log(
        `${warning(
          "[!]"
        )} ORM non reconnu. Choisissez : ${selectedDB.ormOptions.join(", ")}`
      );
    }
    dbConfig.orm = ormChoice.toLowerCase();
  }

  // --- 4. Choix Booléens (Utilise les flags comme defaultInput) ---

  // Valeur par défaut: false, sauf si le flag est explicitement true
  const defaultYarn = getFlagValue(flags, "yarn", false);
  const useYarn = readline.keyInYNStrict(`${info("[?]")} Utiliser Yarn ?`, {
    defaultInput: defaultYarn ? "y" : "n",
  });

  // Valeur par défaut: true, sauf si le flag est explicitement false
  const defaultDocker = getFlagValue(flags, "docker", true);
  const useDocker = readline.keyInYNStrict(
    `${info("[?]")} Generer fichiers Docker ?`,
    { defaultInput: defaultDocker ? "y" : "n" }
  );

  // Valeur par défaut: true
  const defaultAuth = getFlagValue(flags, "auth", true);
  const useAuth = readline.keyInYNStrict(
    `${info("[?]")} Ajouter authentification JWT ?`,
    { defaultInput: defaultAuth ? "y" : "n" }
  );

  // Valeur par défaut: true
  const defaultSwagger = getFlagValue(flags, "swagger", true);
  const useSwagger = readline.keyInYNStrict(
    `${info("[?]")} Installer Swagger ?`,
    { defaultInput: defaultSwagger ? "y" : "n" }
  );

  const packageManager = useYarn ? "yarn" : "npm";

  // --- 5. Configuration Swagger ---
  let swaggerInputs;
  if (useSwagger) {
    console.log(`\n${info("[INFO]")} Configuration Swagger`);
    swaggerInputs = {
      title: readline.question(
        `  Titre API [${getFlagValue(
          flags,
          "swaggerTitle",
          `${currentProjectName} API`
        )}] : `,
        {
          defaultInput: getFlagValue(
            flags,
            "swaggerTitle",
            `${currentProjectName} API`
          ),
        }
      ),
      description: readline.question(
        `  Description [${getFlagValue(
          flags,
          "swaggerDesc",
          "API generated by NestCraftX"
        )}] : `,
        {
          defaultInput: getFlagValue(
            flags,
            "swaggerDesc",
            "API generated by NestCraftX"
          ),
        }
      ),
      version: readline.question(
        `  Version [${getFlagValue(flags, "swaggerVersion", "1.0.0")}] : `,
        {
          defaultInput: getFlagValue(flags, "swaggerVersion", "1.0.0"),
        }
      ),
      endpoint: readline.question(
        `  Endpoint [${getFlagValue(flags, "swaggerEndpoint", "api/docs")}] : `,
        {
          defaultInput: getFlagValue(flags, "swaggerEndpoint", "api/docs"),
        }
      ),
    };
  }

  // --- 6. Entités (Reste entièrement interactif pour la complexité) ---
  const entitiesData = { entities: [], relations: [] };

  if (useAuth) {
    console.log(
      `\n${success("[✓]")} Auth active : entite User ajoutee automatiquement`
    );
    entitiesData.entities.push({
      name: "user",
      fields: [
        { name: "email", type: "string" },
        { name: "password", type: "string" },
        { name: "isActive", type: "boolean" },
      ],
    });
  }

  console.log(
    `\n${info("[INFO]")} Saisie des entites (Mode FULL - Architecture complete)`
  );
  // NOTE: Pas de flag pour automatiser l'ajout d'entités/relations car c'est trop complexe pour les flags CLI.
  let addEntity = readline.keyInYNStrict(`${info("[?]")} Ajouter une entite ?`);
  while (addEntity) {
    // ... (Logique de saisie des entités et champs) ...
    let name;
    while (true) {
      name = readline.question(`\n  Nom de l'entite : `);
      if (/^[A-Za-z][A-Za-z0-9_]*$/.test(name)) break;
      console.log(
        `${warning(
          "[!]"
        )} Nom invalide. Lettres, chiffres, _ (commencez par une lettre).`
      );
    }

    const fields = [];
    console.log(`  Champs pour "${name}" :`);
    while (true) {
      let fname = readline.question("    Nom du champ (vide pour terminer) : ");
      if (!fname) break;
      if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(fname)) {
        console.log(`${warning("[!]")} Nom de champ invalide.`);
        continue;
      }
      let ftype;
      while (true) {
        ftype = readline.question(
          `    Type de "${fname}" (string, number, boolean, Date, enum) : `
        );
        if (ftype) break;
        console.log(`${warning("[!]")} Type requis.`);
      }
      fields.push({ name: fname, type: ftype });
    }

    entitiesData.entities.push({ name, fields });
    console.log(
      `${success("[✓]")} Entite "${name}" ajoutee avec ${
        fields.length
      } champ(s)`
    );

    addEntity = readline.keyInYNStrict(
      `${info("[?]")} Ajouter une autre entite ?`
    );
  }

  // --- 7. Relations (Reste entièrement interactif) ---
  const wantsRelation = readline.keyInYNStrict(
    `${info("[?]")} Ajouter des relations entre entites ?`
  );
  if (wantsRelation && entitiesData.entities.length > 1) {
    console.log(`\n${info("[INFO]")} Configuration des relations`);
    while (true) {
      // ... (Logique de saisie des relations) ...
      console.log("\n  Entites disponibles :");
      entitiesData.entities.forEach((ent, index) =>
        console.log(`    [${index}] ${ent.name}`)
      );

      let fromIndex, toIndex;
      while (true) {
        fromIndex = parseInt(
          readline.question("  Depuis quelle entite ? (index) : "),
          10
        );
        if (!isNaN(fromIndex) && entitiesData.entities[fromIndex]) break;
        console.log(`${warning("[!]")} Indice invalide.`);
      }
      while (true) {
        toIndex = parseInt(
          readline.question("  Vers quelle entite ? (index) : "),
          10
        );
        if (!isNaN(toIndex) && entitiesData.entities[toIndex]) break;
        console.log(`${warning("[!]")} Indice invalide.`);
      }

      let relType;
      while (true) {
        relType = readline.question("  Type de relation (1-1 / 1-n / n-n) : ");
        if (["1-1", "1-n", "n-n"].includes(relType)) break;
        console.log(
          `${warning("[!]")} Type invalide. Choisissez : 1-1, 1-n, n-n`
        );
      }

      const from = entitiesData.entities[fromIndex];
      const to = entitiesData.entities[toIndex];

      entitiesData.relations.push({
        from: from.name,
        to: to.name,
        type: relType,
      });

      console.log(
        `${success("[✓]")} Relation ajoutee : ${from.name} ${relType} ${
          to.name
        }`
      );

      if (relType === "1-1") {
        from.fields.push({
          name: `${to.name.toLowerCase()}Id`,
          type: "string",
        });
      } else if (relType === "1-n") {
        from.fields.push({
          name: `${to.name.toLowerCase()}s`,
          type: `${to.name}[]`,
        });
      } else if (relType === "n-n") {
        from.fields.push({
          name: `${to.name.toLowerCase()}s`,
          type: `${to.name}[]`,
        });
        to.fields.push({
          name: `${from.name.toLowerCase()}s`,
          type: `${from.name}[]`,
        });
      }

      const addMore = readline.keyInYNStrict(
        `${info("[?]")} Ajouter une autre relation ?`
      );
      if (!addMore) break;
    }
  }

  return {
    projectName: currentProjectName,
    useYarn,
    useDocker,
    useAuth,
    useSwagger,
    swaggerInputs,
    packageManager,
    entitiesData,
    selectedDB: selectedDB.name,
    dbConfig,
    mode: "full",
  };
}

/**
 * Récupère la valeur d'un flag, ou la valeur par défaut si le flag n'est pas fourni.
 * Convertit les flags 'true'/'false' en booléens si nécessaire.
 * @param {object} flags - L'objet flags (ex: yargs)
 * @param {string} name - Nom du flag (ex: 'auth', 'dbHost')
 * @param {*} defaultValue - Valeur par défaut si le flag est absent.
 */
function getFlagValue(flags, name, defaultValue) {
  const value = flags[name];
  if (value !== undefined) {
    // Gérer les cas où yargs (ou autre) renvoie une chaîne pour les booléens
    if (value === "true") return true;
    if (value === "false") return false;
    return value;
  }
  return defaultValue;
}
module.exports = { getFullModeInputs };
